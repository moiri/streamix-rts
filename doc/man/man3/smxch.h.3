.TH "include/smxch.h" 3 "Tue Mar 10 2020" "Version v0.5.1" "libsmxrts" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/smxch.h
.SH SYNOPSIS
.br
.PP
\fC#include 'smxtypes\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBSMX_MAX_CHS\fP   10000"
.br
.ti -1c
.RI "#define \fBSMX_CHANNEL_READ\fP(h,  box_name,  ch_name)   \fBsmx_channel_read\fP( h, \fBSMX_SIG_PORT\fP( h, box_name, ch_name, in ) )"
.br
.ti -1c
.RI "#define \fBSMX_CHANNEL_WRITE\fP(h,  box_name,  ch_name,  data)   \fBsmx_channel_write\fP( h, \fBSMX_SIG_PORT\fP( h, box_name, ch_name, out ), data )"
.br
.ti -1c
.RI "#define \fBSMX_GET_READ_ERROR\fP(h,  box_name,  ch_name)   \fBsmx_get_read_error\fP( \fBSMX_SIG_PORT\fP( h, box_name, ch_name, in ) )"
.br
.ti -1c
.RI "#define \fBSMX_GET_WRITE_ERROR\fP(h,  box_name,  ch_name)   \fBsmx_get_write_error\fP( \fBSMX_SIG_PORT\fP( h, box_name, ch_name, out ) )"
.br
.ti -1c
.RI "#define \fBSMX_SET_READ_TIMEOUT\fP(h,  box_name,  ch_name,  sec,  nsec)   \fBsmx_set_read_timeout\fP( \fBSMX_SIG_PORT\fP( h, box_name, ch_name, in ), sec, nsec )"
.br
.ti -1c
.RI "#define \fBSMX_SET_WRITE_TIMEOUT\fP(h,  box_name,  ch_name,  sec,  nsec)   \fBsmx_set_write_timeout\fP( \fBSMX_SIG_PORT\fP( h, box_name, ch_name, out ), sec, nsec )"
.br
.ti -1c
.RI "#define \fBSMX_CHANNEL_SET_CONTENT_FILTER\fP(h,  box_name,  ch_name,  filter)"
.br
.ti -1c
.RI "#define \fBSMX_CHANNEL_SET_TYPE_FILTER\fP(h,  box_name,  ch_name,  count, \&.\&.\&.)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBsmx_channel_change_collector_state\fP (smx_channel_t *ch, \fBsmx_channel_state_t\fP state)"
.br
.ti -1c
.RI "void \fBsmx_channel_change_read_state\fP (smx_channel_t *ch, \fBsmx_channel_state_t\fP state)"
.br
.ti -1c
.RI "void \fBsmx_channel_change_write_state\fP (smx_channel_t *ch, \fBsmx_channel_state_t\fP state)"
.br
.ti -1c
.RI "smx_channel_t * \fBsmx_channel_create\fP (int *ch_cnt, int len, \fBsmx_channel_type_t\fP type, int id, const char *name, const char *cat_name)"
.br
.RI "Create Streamix channel\&. "
.ti -1c
.RI "smx_channel_end_t * \fBsmx_channel_create_end\fP ()"
.br
.ti -1c
.RI "void \fBsmx_channel_destroy\fP (smx_channel_t *ch)"
.br
.RI "Destroy Streamix channel structure\&. "
.ti -1c
.RI "void \fBsmx_channel_destroy_end\fP (smx_channel_end_t *end)"
.br
.RI "Destroy Streamix channel end structure\&. "
.ti -1c
.RI "smx_msg_t * \fBsmx_channel_read\fP (void *h, smx_channel_t *ch)"
.br
.RI "Read the data from an input port\&. "
.ti -1c
.RI "int \fBsmx_channel_ready_to_read\fP (smx_channel_t *ch)"
.br
.RI "Returns the number of available messages in channel\&. "
.ti -1c
.RI "int \fBsmx_channel_ready_to_write\fP (smx_channel_t *ch)"
.br
.RI "Returns the number of available space in a channel\&. "
.ti -1c
.RI "bool \fBsmx_channel_set_content_filter\fP (smx_channel_t *ch, bool filter(smx_msg_t *))"
.br
.ti -1c
.RI "bool \fBsmx_channel_set_filter\fP (smx_net_t *h, smx_channel_t *ch, int count,\&.\&.\&.)"
.br
.ti -1c
.RI "void \fBsmx_channel_terminate_sink\fP (smx_channel_t *ch)"
.br
.ti -1c
.RI "void \fBsmx_channel_terminate_source\fP (smx_channel_t *ch)"
.br
.ti -1c
.RI "int \fBsmx_channel_write\fP (void *h, smx_channel_t *ch, smx_msg_t *msg)"
.br
.RI "Write data to an output port\&. "
.ti -1c
.RI "smx_collector_t * \fBsmx_collector_create\fP ()"
.br
.ti -1c
.RI "void \fBsmx_collector_destroy\fP (smx_collector_t *collector)"
.br
.ti -1c
.RI "void \fBsmx_collector_terminate\fP (smx_channel_t *ch)"
.br
.ti -1c
.RI "void \fBsmx_connect\fP (smx_channel_t **dest, smx_channel_t *src, int net_id, const char *net_name, const char *mode, int *count)"
.br
.ti -1c
.RI "void \fBsmx_connect_guard\fP (smx_channel_t *ch, smx_guard_t *guard)"
.br
.ti -1c
.RI "void \fBsmx_connect_in\fP (smx_channel_t **dest, smx_channel_t *src, smx_net_t *net, const char *mode, int *count)"
.br
.ti -1c
.RI "void \fBsmx_connect_out\fP (smx_channel_t **dest, smx_channel_t *src, smx_net_t *net, const char *mode, int *count)"
.br
.ti -1c
.RI "smx_fifo_t * \fBsmx_fifo_create\fP (int length)"
.br
.RI "Create Streamix FIFO channel\&. "
.ti -1c
.RI "void \fBsmx_fifo_destroy\fP (smx_fifo_t *fifo)"
.br
.RI "Destroy Streamix FIFO channel structure\&. "
.ti -1c
.RI "smx_msg_t * \fBsmx_fifo_read\fP (void *h, smx_channel_t *ch, smx_fifo_t *fifo)"
.br
.RI "read from a Streamix FIFO channel "
.ti -1c
.RI "smx_msg_t * \fBsmx_fifo_d_read\fP (void *h, smx_channel_t *ch, smx_fifo_t *fifo)"
.br
.RI "read from a Streamix FIFO_D channel "
.ti -1c
.RI "smx_msg_t * \fBsmx_fifo_dd_read\fP (void *h, smx_channel_t *ch, smx_fifo_t *fifo)"
.br
.RI "read from a Streamix FIFO_DD channel "
.ti -1c
.RI "int \fBsmx_fifo_write\fP (void *h, smx_channel_t *ch, smx_fifo_t *fifo, smx_msg_t *msg)"
.br
.RI "write to a Streamix FIFO channel "
.ti -1c
.RI "int \fBsmx_d_fifo_write\fP (void *h, smx_channel_t *ch, smx_fifo_t *fifo, smx_msg_t *msg)"
.br
.RI "write to a Streamix D_FIFO channel "
.ti -1c
.RI "smx_channel_t * \fBsmx_get_channel_by_name\fP (smx_channel_t **ports, int count, const char *name)"
.br
.ti -1c
.RI "\fBsmx_channel_err_t\fP \fBsmx_get_read_error\fP (smx_channel_t *ch)"
.br
.ti -1c
.RI "\fBsmx_channel_err_t\fP \fBsmx_get_write_error\fP (smx_channel_t *ch)"
.br
.ti -1c
.RI "smx_guard_t * \fBsmx_guard_create\fP (int iats, int iatns, smx_channel_t *ch)"
.br
.RI "create timed guard structure and initialise timer "
.ti -1c
.RI "void \fBsmx_guard_destroy\fP (smx_guard_t *guard)"
.br
.RI "destroy the guard structure "
.ti -1c
.RI "int \fBsmx_guard_write\fP (void *h, smx_channel_t *ch)"
.br
.RI "imposes a rate-controld on write operations "
.ti -1c
.RI "int \fBsmx_d_guard_write\fP (void *h, smx_channel_t *ch, smx_msg_t *msg)"
.br
.RI "imposes a rate-control on decoupled write operations "
.ti -1c
.RI "int \fBsmx_set_read_timeout\fP (smx_channel_t *ch, long sec, long nsec)"
.br
.ti -1c
.RI "int \fBsmx_set_write_timeout\fP (smx_channel_t *ch, long sec, long nsec)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBAuthor:\fP
.RS 4
Simon Maurer 
.RE
.PP
\fBLicense:\fP
.RS 4
This Source Code Form is subject to the terms of the Mozilla Public License, v\&. 2\&.0\&. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/\&.
.RE
.PP
Channel and FIFO definitions for the runtime system library of Streamix 
.SH "Macro Definition Documentation"
.PP 
.SS "#define SMX_CHANNEL_READ(h, box_name, ch_name)   \fBsmx_channel_read\fP( h, \fBSMX_SIG_PORT\fP( h, box_name, ch_name, in ) )"
Read from a streamix channel by accessing a net input port\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The pointer to the net handler\&. 
.br
\fIbox_name\fP The name of the box\&. Note that this is not a string but the literal name of the box (without quotation marks)\&. 
.br
\fIch_name\fP The name of the input port\&. Note that this is not a string but the literal name of the port (without quotation marks)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to a message type ::smx_msg_t or NULL if something went wrong\&. Use the macro \fBSMX_GET_READ_ERROR()\fP to find out the cause of an error\&. 
.RE
.PP

.SS "#define SMX_CHANNEL_SET_CONTENT_FILTER(h, box_name, ch_name, filter)"
\fBValue:\fP
.PP
.nf
smx_channel_set_content_filter( SMX_SIG_PORT( h, box_name, ch_name, in ),\
            filter )
.fi
Set a message content filter on a channel\&. The filter is a function that operates on the message content\&. The function receives the message as parameter and must return either true if the filter passes or false if the filter fails\&.
.PP
If the filter failes, the macro \fBSMX_CHANNEL_WRITE()\fP silently dismisses the message and returns 0\&. A content filter fail does not count as error\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The pointer to the net handler\&. 
.br
\fIbox_name\fP The name of the box\&. Note that this is not a string but the literal name of the box (without quotation marks)\&. 
.br
\fIch_name\fP The name of the output port\&. Note that this is not a string but the literal name of the port (without quotation marks)\&. 
.br
\fIfilter\fP A pointer to the filter function\&. The filter function must return a booloan and takes a pointer to the message to be checked as parameter\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success or false on failure\&. 
.RE
.PP

.SS "#define SMX_CHANNEL_SET_TYPE_FILTER(h, box_name, ch_name, count,  \&.\&.\&.)"
\fBValue:\fP
.PP
.nf
smx_channel_set_filter( h, SMX_SIG_PORT( h, box_name, ch_name, in ),\
            count, ##__VA_ARGS__ )
.fi
Set a message type filter on a channel filter\&. A channel filter allows to whitelist message types\&. If the filter is set, only messages of the specified types are allowed to be written to a channel\&. One filter is an arbitrary string or NULL to allow messages with undefined message type\&. If a message type does not match any whitelisted types, an error is logged and the message is dismissed\&.
.PP
If the filter failes, the macro \fBSMX_CHANNEL_WRITE()\fP returns -1 and sets the error SMX_CHANNEL_ERR_FILTER\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The pointer to the net handler\&. 
.br
\fIbox_name\fP The name of the box\&. Note that this is not a string but the literal name of the box (without quotation marks)\&. 
.br
\fIch_name\fP The name of the output port\&. Note that this is not a string but the literal name of the port (without quotation marks)\&. 
.br
\fIcount\fP The number of filter arguments passed to the function 
.br
\fI\&.\&.\&.\fP Any number of string arguments\&. If the message type matches any of these the filter check passed\&. NULL is a valid argument\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success or false on failure\&. 
.RE
.PP

.SS "#define SMX_CHANNEL_WRITE(h, box_name, ch_name, data)   \fBsmx_channel_write\fP( h, \fBSMX_SIG_PORT\fP( h, box_name, ch_name, out ), data )"
Write to a streamix channel by accessing a net output port\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The pointer to the net handler\&. 
.br
\fIbox_name\fP The name of the box\&. Note that this is not a string but the literal name of the box (without quotation marks)\&. 
.br
\fIch_name\fP The name of the output port\&. Note that this is not a string but the literal name of the port (without quotation marks)\&. 
.br
\fIdata\fP A pointer to an allocated message of type ::smx_msg_t\&. Use the macro \fBSMX_MSG_CREATE()\fP to create a new message if required\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 on failure\&. Use the macro \fBSMX_GET_WRITE_ERROR()\fP to find out the cause of an error\&. 
.RE
.PP

.SS "#define SMX_GET_READ_ERROR(h, box_name, ch_name)   \fBsmx_get_read_error\fP( \fBSMX_SIG_PORT\fP( h, box_name, ch_name, in ) )"
Get the error code of a channel read operation\&. Use this macro if \fBSMX_CHANNEL_READ()\fP failed\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The pointer to the net handler\&. 
.br
\fIbox_name\fP The name of the box\&. Note that this is not a string but the literal name of the box (without quotation marks)\&. 
.br
\fIch_name\fP The name of the input port\&. Note that this is not a string but the literal name of the port (without quotation marks)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The error code of the operation\&. Refer to \fBsmx_channel_err_e\fP for a description of the error codes\&. 
.RE
.PP

.SS "#define SMX_GET_WRITE_ERROR(h, box_name, ch_name)   \fBsmx_get_write_error\fP( \fBSMX_SIG_PORT\fP( h, box_name, ch_name, out ) )"
Get the error code of a channel write operation\&. Use this macro if \fBSMX_CHANNEL_WRITE()\fP failed\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The pointer to the net handler\&. 
.br
\fIbox_name\fP The name of the box\&. Note that this is not a string but the literal name of the box (without quotation marks)\&. 
.br
\fIch_name\fP The name of the input port\&. Note that this is not a string but the literal name of the port (without quotation marks)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The error code of the operation\&. Refer to \fBsmx_channel_err_e\fP for a description of the error codes\&. 
.RE
.PP

.SS "#define SMX_MAX_CHS   10000"
The number of maximal allowed channel in one streamix application\&. 
.SS "#define SMX_SET_READ_TIMEOUT(h, box_name, ch_name, sec, nsec)   \fBsmx_set_read_timeout\fP( \fBSMX_SIG_PORT\fP( h, box_name, ch_name, in ), sec, nsec )"
Set a timeout on the channel source
.PP
\fBParameters:\fP
.RS 4
\fIh\fP The pointer to the net handler\&. 
.br
\fIbox_name\fP The name of the box\&. Note that this is not a string but the literal name of the box (without quotation marks)\&. 
.br
\fIch_name\fP The name of the input port\&. Note that this is not a string but the literal name of the port (without quotation marks)\&. 
.br
\fIsec\fP The number of seconds to wait 
.br
\fInsec\fP The number of nanoseconds to wait 
.RE
.PP
\fBReturns:\fP
.RS 4
The error code of the operation\&. Refer to \fBsmx_channel_err_e\fP for a description of the error codes\&. 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "void smx_channel_change_collector_state (smx_channel_t * ch, \fBsmx_channel_state_t\fP state)"
Change the state of a channel collector\&. The state is only changed if the current state is differnt than the new state and than the end state\&.
.PP
\fBParameters:\fP
.RS 4
\fIch\fP pointer to the channel 
.br
\fIstate\fP the new state
.RE
.PP
\fBAuthor:\fP
.RS 4
Simon Maurer 
.RE
.PP
\fBLicense:\fP
.RS 4
This Source Code Form is subject to the terms of the Mozilla Public License, v\&. 2\&.0\&. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/\&.
.RE
.PP
Channel and FIFO definitions for the runtime system library of Streamix 
.SS "void smx_channel_change_read_state (smx_channel_t * ch, \fBsmx_channel_state_t\fP state)"
Change the read state of a channel\&. The state is only changed if the current state is differnt than the new state and than the end state\&.
.PP
\fBParameters:\fP
.RS 4
\fIch\fP pointer to the channel 
.br
\fIstate\fP the new state 
.RE
.PP

.SS "void smx_channel_change_write_state (smx_channel_t * ch, \fBsmx_channel_state_t\fP state)"
Change the write state of a channel\&. The state is only changed if the current state is differnt than the new state and than the end state\&.
.PP
\fBParameters:\fP
.RS 4
\fIch\fP pointer to the channel 
.br
\fIstate\fP the new state 
.RE
.PP

.SS "smx_channel_t* smx_channel_create (int * ch_cnt, int len, \fBsmx_channel_type_t\fP type, int id, const char * name, const char * cat_name)"

.PP
Create Streamix channel\&. 
.PP
\fBParameters:\fP
.RS 4
\fIch_cnt\fP pointer to the channel counter (is increased by one after channel creation) 
.br
\fIlen\fP length of a FIFO 
.br
\fItype\fP type of the buffer 
.br
\fIid\fP unique identifier of the channel 
.br
\fIname\fP name of the channel 
.br
\fIcat_name\fP name of the channel zlog category 
.RE
.PP
\fBReturns:\fP
.RS 4
a pointer to the created channel or NULL 
.RE
.PP

.SS "smx_channel_end_t* smx_channel_create_end ()"
Create a channel end\&.
.PP
\fBReturns:\fP
.RS 4
a pointer to a ne channel end or NULL if something went wrong 
.RE
.PP

.SS "void smx_channel_destroy (smx_channel_t * ch)"

.PP
Destroy Streamix channel structure\&. 
.PP
\fBParameters:\fP
.RS 4
\fIch\fP pointer to the channel to destroy 
.RE
.PP

.SS "void smx_channel_destroy_end (smx_channel_end_t * end)"

.PP
Destroy Streamix channel end structure\&. 
.PP
\fBParameters:\fP
.RS 4
\fIend\fP pointer to the channel end to destroy 
.RE
.PP

.SS "smx_msg_t* smx_channel_read (void * h, smx_channel_t * ch)"

.PP
Read the data from an input port\&. Allows to access the channel and read data\&. The channel is protected by mutual exclusion\&. The macro \fBSMX_CHANNEL_READ()\fP provides a convenient interface to access the ports by name\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP pointer to the net handler 
.br
\fIch\fP pointer to the channel 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to a message structure \fBsmx_msg_s\fP or NULL if something went wrong\&. 
.RE
.PP

.SS "int smx_channel_ready_to_read (smx_channel_t * ch)"

.PP
Returns the number of available messages in channel\&. 
.PP
\fBParameters:\fP
.RS 4
\fIch\fP pointer to the channel 
.RE
.PP
\fBReturns:\fP
.RS 4
number of available messages in channel or -1 on failure 
.RE
.PP

.SS "int smx_channel_ready_to_write (smx_channel_t * ch)"

.PP
Returns the number of available space in a channel\&. 
.PP
\fBParameters:\fP
.RS 4
\fIch\fP pointer to the channel 
.RE
.PP
\fBReturns:\fP
.RS 4
number of available space in a channel or -1 on failure 
.RE
.PP

.SS "bool smx_channel_set_content_filter (smx_channel_t * ch, bool  filtersmx_msg_t *)"
Set a channel filter to only allow messages of a certain content to be written to this channel\&.
.PP
\fBParameters:\fP
.RS 4
\fIch\fP pointer to the channel 
.br
\fIfilter\fP a pointer to a function returning a booloan and taking the message to be filtered as argument\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success or false on failure\&. 
.RE
.PP

.SS "bool smx_channel_set_filter (smx_net_t * h, smx_channel_t * ch, int count,  \&.\&.\&.)"
Set the channel filter to only allow messages of a certain type to be written to this channel\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP pointer to the net handler\&. 
.br
\fIch\fP pointer to the channel 
.br
\fIcount\fP The number of filter arguments passed to the function 
.br
\fI\&.\&.\&.\fP Any number of string arguments\&. If the message type matches any of these the filter check passed\&. NULL is a valid argument\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success or false on failure\&. 
.RE
.PP

.SS "void smx_channel_terminate_sink (smx_channel_t * ch)"
Send the termination signal to a channel sink
.PP
\fBParameters:\fP
.RS 4
\fIch\fP pointer to the channel 
.RE
.PP

.SS "void smx_channel_terminate_source (smx_channel_t * ch)"
Send the termination signal to a channel source
.PP
\fBParameters:\fP
.RS 4
\fIch\fP pointer to the channel 
.RE
.PP

.SS "int smx_channel_write (void * h, smx_channel_t * ch, smx_msg_t * msg)"

.PP
Write data to an output port\&. Allows to access the channel and write data\&. The channel ist protected by mutual exclusion\&. The macro \fBSMX_CHANNEL_WRITE( h, net, port, data )\fP provides a convenient interface to access the ports by name\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP pointer to the net handler 
.br
\fIch\fP pointer to the channel 
.br
\fImsg\fP pointer to the a message structure 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, -1 otherwise 
.RE
.PP

.SS "smx_collector_t* smx_collector_create ()"
Create a collector structure and initialize it\&.
.PP
\fBReturns:\fP
.RS 4
a pointer to the created collector strcuture or NULL\&. 
.RE
.PP

.SS "void smx_collector_destroy (smx_collector_t * collector)"
Destroy and deinit a collector structure\&.
.PP
\fBParameters:\fP
.RS 4
\fIcollector\fP a pointer to the collector structure to be destroyed\&. 
.RE
.PP

.SS "void smx_collector_terminate (smx_channel_t * ch)"
Send the termination signal to the collector
.PP
\fBParameters:\fP
.RS 4
\fIch\fP pointer to the channel 
.RE
.PP

.SS "void smx_connect (smx_channel_t ** dest, smx_channel_t * src, int net_id, const char * net_name, const char * mode, int * count)"
Connect a channel to a net by name matching\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP a pointer to the destination 
.br
\fIsrc\fP a pointer to the source 
.br
\fInet_id\fP the id of the net 
.br
\fInet_name\fP the name of the net 
.br
\fImode\fP the direction of the connection 
.br
\fIcount\fP pointer to th econnected port counter 
.RE
.PP

.SS "void smx_connect_guard (smx_channel_t * ch, smx_guard_t * guard)"
Connect a guard to a channel
.PP
\fBParameters:\fP
.RS 4
\fIch\fP the target channel 
.br
\fIguard\fP the guard to be connected 
.RE
.PP

.SS "void smx_connect_in (smx_channel_t ** dest, smx_channel_t * src, smx_net_t * net, const char * mode, int * count)"
Connect a channel to an input of a net\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP a pointer to the destination 
.br
\fIsrc\fP a pointer to the source 
.br
\fInet\fP a pointer to the net 
.br
\fImode\fP the direction of the connection 
.br
\fIcount\fP pointer to th econnected port counter 
.RE
.PP

.SS "void smx_connect_out (smx_channel_t ** dest, smx_channel_t * src, smx_net_t * net, const char * mode, int * count)"
Connect a channel to an output of a net\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP a pointer to the destination 
.br
\fIsrc\fP a pointer to the source 
.br
\fInet\fP a pointer to the net 
.br
\fImode\fP the direction of the connection 
.br
\fIcount\fP pointer to th econnected port counter 
.RE
.PP

.SS "int smx_d_fifo_write (void * h, smx_channel_t * ch, smx_fifo_t * fifo, smx_msg_t * msg)"

.PP
write to a Streamix D_FIFO channel Write to a channel that is decoupled at the input (the produced is decoupled at the output)\&. This means that the tail of the D_FIFO will potentially be overwritten\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP pointer to the net handler 
.br
\fIch\fP pointer to channel struct of the FIFO 
.br
\fIfifo\fP pointer to a D_FIFO channel 
.br
\fImsg\fP pointer to the data 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, 1 otherwise 
.RE
.PP

.SS "int smx_d_guard_write (void * h, smx_channel_t * ch, smx_msg_t * msg)"

.PP
imposes a rate-control on decoupled write operations A message is discarded if it did not reach the specified minimal inter- arrival time (messages are not buffered and delayed, it's only a very simple implementation)
.PP
\fBParameters:\fP
.RS 4
\fIh\fP pointer to the net handler 
.br
\fIch\fP pointer to the channel structure 
.br
\fImsg\fP pointer to the message structure
.RE
.PP
\fBReturns:\fP
.RS 4
-1 if message was discarded, 0 otherwise 
.RE
.PP

.SS "smx_fifo_t* smx_fifo_create (int length)"

.PP
Create Streamix FIFO channel\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlength\fP length of the FIFO 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to the created FIFO 
.RE
.PP

.SS "smx_msg_t* smx_fifo_d_read (void * h, smx_channel_t * ch, smx_fifo_t * fifo)"

.PP
read from a Streamix FIFO_D channel Read from a channel that is decoupled at the output (the consumer is decoupled at the input)\&. This means that the msg at the head of the FIFO_D will potentially be duplicated\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP pointer to the net handler 
.br
\fIch\fP pointer to channel struct of the FIFO 
.br
\fIfifo\fP pointer to a FIFO_D channel 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to a message structure 
.RE
.PP

.SS "smx_msg_t* smx_fifo_dd_read (void * h, smx_channel_t * ch, smx_fifo_t * fifo)"

.PP
read from a Streamix FIFO_DD channel Read from a channel that is decoupled at the output and connected to a temporal firewall\&. The read is non-blocking but no duplication of messages is done\&. If no message is available NULL is returned\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP pointer to the net handler 
.br
\fIch\fP pointer to channel struct of the FIFO 
.br
\fIfifo\fP pointer to a FIFO_D channel 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to a message structure 
.RE
.PP

.SS "void smx_fifo_destroy (smx_fifo_t * fifo)"

.PP
Destroy Streamix FIFO channel structure\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfifo\fP pointer to the channel to destroy 
.RE
.PP

.SS "smx_msg_t* smx_fifo_read (void * h, smx_channel_t * ch, smx_fifo_t * fifo)"

.PP
read from a Streamix FIFO channel 
.PP
\fBParameters:\fP
.RS 4
\fIh\fP pointer to the net handler 
.br
\fIch\fP pointer to channel struct of the FIFO 
.br
\fIfifo\fP pointer to a FIFO channel 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to a message structure 
.RE
.PP

.SS "int smx_fifo_write (void * h, smx_channel_t * ch, smx_fifo_t * fifo, smx_msg_t * msg)"

.PP
write to a Streamix FIFO channel 
.PP
\fBParameters:\fP
.RS 4
\fIh\fP pointer to the net handler 
.br
\fIch\fP pointer to channel struct of the FIFO 
.br
\fIfifo\fP pointer to a FIFO channel 
.br
\fImsg\fP pointer to the data 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, 1 otherwise 
.RE
.PP

.SS "smx_channel_t* smx_get_channel_by_name (smx_channel_t ** ports, int count, const char * name)"
Given a port name return a pointer to the port\&.
.PP
\fBParameters:\fP
.RS 4
\fIports\fP an array of ports to be searched 
.br
\fIcount\fP the number of ports to search 
.br
\fIname\fP the name to search for 
.RE
.PP
\fBReturns:\fP
.RS 4
the pointer to a port on success, NULL otherwise 
.RE
.PP

.SS "\fBsmx_channel_err_t\fP smx_get_read_error (smx_channel_t * ch)"
Get the read error on a channel\&.
.PP
\fBParameters:\fP
.RS 4
\fIch\fP Pointer to the channel 
.RE
.PP
\fBReturns:\fP
.RS 4
The error value indicationg the problem 
.RE
.PP

.SS "\fBsmx_channel_err_t\fP smx_get_write_error (smx_channel_t * ch)"
Get the write error on a channel\&.
.PP
\fBParameters:\fP
.RS 4
\fIch\fP Pointer to the channel 
.RE
.PP
\fBReturns:\fP
.RS 4
The error value indicationg the problem 
.RE
.PP

.SS "smx_guard_t* smx_guard_create (int iats, int iatns, smx_channel_t * ch)"

.PP
create timed guard structure and initialise timer 
.PP
\fBParameters:\fP
.RS 4
\fIiats\fP minimal inter-arrival time in seconds 
.br
\fIiatns\fP minimal inter-arrival time in nano seconds 
.br
\fIch\fP pointer to the channel 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to the created guard structure 
.RE
.PP

.SS "void smx_guard_destroy (smx_guard_t * guard)"

.PP
destroy the guard structure 
.PP
\fBParameters:\fP
.RS 4
\fIguard\fP pointer to the guard structure 
.RE
.PP

.SS "int smx_guard_write (void * h, smx_channel_t * ch)"

.PP
imposes a rate-controld on write operations A producer is blocked until the minimum inter-arrival-time between two consecutive messges has passed
.PP
\fBParameters:\fP
.RS 4
\fIh\fP pointer to the net handler 
.br
\fIch\fP pointer to the channel structure 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, 1 otherwise 
.RE
.PP

.SS "int smx_set_read_timeout (smx_channel_t * ch, long sec, long nsec)"
Set the channel read timeout\&.
.PP
\fBParameters:\fP
.RS 4
\fIend\fP Pointer to the channel end 
.br
\fIsec\fP The second part of the timer 
.br
\fInsec\fP The nanosecond part of the timer 
.RE
.PP
\fBReturns:\fP
.RS 4
The error value indicationg the problem 
.RE
.PP

.SS "int smx_set_write_timeout (smx_channel_t * ch, long sec, long nsec)"
Set the channel write timeout\&.
.PP
\fBParameters:\fP
.RS 4
\fIend\fP Pointer to the channel end 
.br
\fIsec\fP The second part of the timer 
.br
\fInsec\fP The nanosecond part of the timer 
.RE
.PP
\fBReturns:\fP
.RS 4
The error value indicationg the problem 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for libsmxrts from the source code\&.
